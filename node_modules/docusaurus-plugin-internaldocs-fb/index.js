"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 *
 * @format
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_1 = __importDefault(require("webpack"));
const snippets_1 = require("./lib/remark/snippets");
const tracking_file_1 = require("./lib/tracking-file");
const path_1 = __importDefault(require("path"));
const child_process_1 = __importDefault(require("child_process"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const validate_peer_dependencies_1 = __importDefault(require("validate-peer-dependencies"));
let haveWarnedAboutReferencedFiles = false;
function plugin(context, opts) {
    // Throw a useful error if an incompatible version of Docusaurus is used with this plugin
    (0, validate_peer_dependencies_1.default)(__dirname);
    return {
        name: 'internaldocs-fb',
        configureWebpack: () => {
            return {
                resolve: {
                    fallback: {
                        assert: require.resolve('assert'),
                        buffer: require.resolve('buffer'),
                        fs: false,
                        path: require.resolve('path-browserify'),
                    },
                },
                plugins: [
                    new webpack_1.default.EnvironmentPlugin({
                        FB_INTERNAL: process.env.FB_INTERNAL || false,
                        PHABRICATOR_DIFF_NUMBER: process.env.PHABRICATOR_DIFF_NUMBER || '',
                    }),
                ],
            };
        },
        injectHtmlTags: () => {
            return {
                preBodyTags: [
                    `<div style="display: none; text-align: center; background-color: white; color: black;" id="internaldocs-banner"></div>`,
                ],
            };
        },
        postBuild: async (props) => {
            await fs_extra_1.default.ensureDir(path_1.default.resolve(props.outDir, '_src'));
            let docsPath = path_1.default.resolve(props.siteDir, 'docs');
            if (opts.docs.path != undefined) {
                docsPath = path_1.default.resolve(props.siteDir, opts.docs.path);
            }
            const dest = path_1.default.resolve(props.outDir, '_src/');
            await fs_extra_1.default.copy(docsPath, dest, { recursive: true });
            await processReferencedFiles(opts, false);
        },
        getClientModules: () => {
            return [path_1.default.resolve(__dirname, './module')];
        },
        getThemePath: () => {
            return path_1.default.resolve(__dirname, './theme');
        },
        getTypeScriptThemePath: () => {
            return path_1.default.resolve(__dirname, 'src', 'theme');
        },
        contentLoaded: async ({ actions }) => {
            // There's no (implemented) postStart hook, so routinely check for referenced files
            // while start is running.
            // Use appendOnly during yarn start because it doesn't always process all files to find exhaustive list
            const { setGlobalData } = actions;
            let docsDir = path_1.default.resolve(context.siteDir, 'docs');
            if (opts.docs.path != undefined) {
                docsDir = path_1.default.resolve(context.siteDir, opts.docs.path);
            }
            const globalData = {
                opts,
                docsDir,
                repoRootToWebsiteRoot: context.siteDir
                    .replace(inferHgRepoRoot(), '')
                    .replace(/^\//, ''),
            };
            setGlobalData(globalData);
            setInterval(async () => await processReferencedFiles(opts, true), 5000);
        },
    };
}
exports.default = plugin;
function inferTrackingFile() {
    const knownfiles = {
        fbsource: 'xplat/staticdocs/WATCHED_FILES',
        www: 'scripts/static_docs/WATCHED_FILES',
    };
    try {
        const repoName = child_process_1.default
            .execSync('hg config fbconduit.reponame')
            .toString()
            .trim();
        return knownfiles[repoName];
    }
    catch (e) {
        return undefined;
    }
}
function inferHgRepoRoot() {
    try {
        return child_process_1.default.execSync('hg root').toString().trim();
    }
    catch (e) {
        return '';
    }
}
async function processReferencedFiles(opts, appendOnly) {
    const { staticDocsProject, trackingFile = inferTrackingFile() } = opts;
    const files = (0, snippets_1.getReferencedFiles)();
    if (files.length > 0) {
        if (typeof staticDocsProject !== 'string' ||
            typeof trackingFile !== 'string') {
            if (!haveWarnedAboutReferencedFiles) {
                haveWarnedAboutReferencedFiles = true;
                console.warn(`
[Static Docs] Warning: This site is embedding code samples from files, but it doesn't have automatic watched-files tracking setup.
This means that updates to referenced files could break your documentation without triggering a build.

Follow the instructions at https://www.internalfb.com/intern/wiki/Static_Docs/Extra_Documentation_Features/#tracking-file
to get guranteed build safety when referenced files change.`);
            }
            return;
        }
        await (0, tracking_file_1.updateTrackingFile)({
            staticDocsProject: staticDocsProject,
            trackingFileLocation: trackingFile,
            referencedFiles: (0, snippets_1.getReferencedFiles)(),
            appendOnly,
        });
    }
}
