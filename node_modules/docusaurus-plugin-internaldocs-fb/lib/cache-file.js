"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _CacheFile_currentCache, _CacheFile_filepath;
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheFile = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const EMPTY_CACHE = {
    snippets: {},
    description: `@${"generated"}`,
};
class CacheFile {
    constructor() {
        _CacheFile_currentCache.set(this, EMPTY_CACHE);
        _CacheFile_filepath.set(this, void 0);
        // docusaurus expects to be called from a directory with `docusaurus.config.js`
        // or explicityl provided a path to a directory with config file
        // See documentation about `[sitedir]`
        // @see https://docusaurus.io/docs/cli#docusaurus-start-sitedir
        //
        // Alternatevely parse `process.argv` for commands `start` & `build`
        // to see if there is [sitedir] provided
        if (!fs_1.default.existsSync(path_1.default.resolve('docusaurus.config.js'))) {
            throw new Error('Command ran from a directory not containing docusaurus.config.js');
        }
        __classPrivateFieldSet(this, _CacheFile_filepath, path_1.default.resolve('fb/sdoc-cache.json'), "f");
        if (fs_1.default.existsSync(__classPrivateFieldGet(this, _CacheFile_filepath, "f"))) {
            const jsonString = fs_1.default.readFileSync(__classPrivateFieldGet(this, _CacheFile_filepath, "f")).toString();
            __classPrivateFieldSet(this, _CacheFile_currentCache, JSON.parse(jsonString), "f");
        }
        else {
            fs_1.default.mkdirSync(path_1.default.dirname(__classPrivateFieldGet(this, _CacheFile_filepath, "f")), { recursive: true });
            fs_1.default.writeFileSync(__classPrivateFieldGet(this, _CacheFile_filepath, "f"), JSON.stringify(EMPTY_CACHE));
        }
    }
    getSnippet({ repo, file, start, end }) {
        var _a, _b, _c;
        const snippetFile = (_a = __classPrivateFieldGet(this, _CacheFile_currentCache, "f").snippets[repo]) === null || _a === void 0 ? void 0 : _a[file];
        if (snippetFile === undefined)
            return null;
        return (_c = (_b = snippetFile.slices.find(start && end
            ? x => x.start === start && x.end === end
            : x => x.start === null && x.end === null)) === null || _b === void 0 ? void 0 : _b.content) !== null && _c !== void 0 ? _c : null;
    }
    syncCacheFile({ usedSnippets }) {
        const snippetsDict = usedSnippets.reduce((acc, s) => {
            acc[`${s.repo}$$${s.file}${s.start ? `$$${s.start}$$${s.end}` : ''}`] = s.content;
            return acc;
        }, {});
        const uniqueUsedSnippets = Object
            .keys(snippetsDict)
            // alphabetic
            .sort()
            .reduce((acc, key) => {
            const [repo, file, start, end] = key.split('$$');
            if (!(repo in acc))
                acc[repo] = {};
            if (!(file in acc[repo]))
                acc[repo][file] = { slices: [] };
            acc[repo][file].slices.push({
                // todo insert only the snippet itself
                content: snippetsDict[key],
                ...(start && end ? { start, end } : { start: null, end: null })
            });
            return acc;
        }, {});
        const newCacheContent = JSON.stringify({
            ...EMPTY_CACHE,
            ...__classPrivateFieldGet(this, _CacheFile_currentCache, "f"),
            snippets: uniqueUsedSnippets,
        }, null, 2);
        fs_1.default.writeFileSync(__classPrivateFieldGet(this, _CacheFile_filepath, "f"), newCacheContent);
    }
}
_CacheFile_currentCache = new WeakMap(), _CacheFile_filepath = new WeakMap();
exports.cacheFile = new CacheFile();
