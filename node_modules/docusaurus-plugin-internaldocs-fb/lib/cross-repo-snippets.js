"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 *
 * @format
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileContent = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const auth_1 = require("./auth");
const errors_1 = require("./errors");
const CODE_SNIPPET_URL = 'https://interngraph.intern.facebook.com/sdoc/code-snippets/';
const IN_MEMORY_CACHE = {};
const FETCH_TIMEOUT = 15 * 1000;
/**
 * Request the content of a file from another repo.
 *
 * Will throw subtypes of StaticDocsError depending on conditions, which must be handled appropriately.
 * See @file errors.ts for explanations of possible errors and how to handle them.
 *
 * @param repo examples: 'www', 'fbsource'...
 * @param filepath should be relative to the repo root, e.g. 'fbandroid/something'
 */
async function getFileContent(repo, filepath) {
    const token = await (0, auth_1.loadToken)();
    if (token === null) {
        throw new errors_1.UnauthenticatedError();
    }
    if (!(repo in IN_MEMORY_CACHE)) {
        IN_MEMORY_CACHE[repo] = {};
    }
    if (filepath in IN_MEMORY_CACHE[repo]) {
        return IN_MEMORY_CACHE[repo][filepath];
    }
    // Detect offline state / off-vpn by timing out requests
    // TODO: use AbortController after updating to node v16
    const timeout = setTimeout(() => {
        throw new errors_1.OfflineError('Timed out waiting for code snippet. Perhaps you need to connect to VPN');
    }, FETCH_TIMEOUT);
    try {
        const result = await (0, node_fetch_1.default)(CODE_SNIPPET_URL, {
            method: 'POST',
            body: `${authQueryString(token)}&repo=${repo}&file_path=${filepath}`,
        });
        const content = await parseResponse(result);
        IN_MEMORY_CACHE[repo][filepath] = content;
        return IN_MEMORY_CACHE[repo][filepath];
    }
    finally {
        clearTimeout(timeout);
    }
}
exports.getFileContent = getFileContent;
function authQueryString(token) {
    if (token.type === 'oauth') {
        return `access_token=${token.payload}`;
    }
    if (token.type === 'cat') {
        return `crypto_auth_tokens=${token.payload}&cat_app=${token.app}`;
    }
    throw new Error(`Unexpected token type: ${JSON.stringify(token)}`);
}
async function parseResponse(response) {
    if (!response.ok) {
        throw new errors_1.UnauthenticatedError('Request for code snippet rejected. Perhaps the auth token has expired/corrupted');
    }
    const parsed = await response.json();
    if ('error' in parsed) {
        // If we get an explicit error response, this means we can connect fine,
        // but something is wrong, like the file couldn't be found.
        // Surface this so the user can be informed.
        throw new errors_1.InvalidReferenceError(`Failed to retrieve code snippet: ${parsed.error}`);
    }
    return parsed.content;
}
