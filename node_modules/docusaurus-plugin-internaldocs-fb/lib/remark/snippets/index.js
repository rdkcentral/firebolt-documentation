"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReferencedFiles = exports.getSnippet = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const arguments_1 = require("./arguments");
const errors_1 = require("../../errors");
const auth_1 = require("../../auth");
const referencedFiles = new Set();
function codeImport(options = {}) {
    return function transformer(tree, file) {
        var _a, _b;
        const codes = [];
        const promises = [];
        (0, unist_util_visit_1.default)(tree, 'code', (node, index, parent) => {
            codes.push([node, index, parent]);
        });
        for (const [node] of codes) {
            // If someone tries to import a file, but forgets to add a language tag e.g ```json
            // then the meta string will be interpreted as the language. So check the lang prop for file=
            // and show a helpful error if this is the case, or else importing wont work for them.
            if (hasLang(node) && node.lang.startsWith('file=')) {
                throw new Error(`Language tag missing on code block snippet in ${file.history}`);
            }
            if (!node.meta) {
                continue;
            }
            const args = (0, arguments_1.parseArgs)(node.meta);
            if (!args.file) {
                continue;
            }
            const baseDir = (_a = options.baseDir) !== null && _a !== void 0 ? _a : ((_b = file.dirname) !== null && _b !== void 0 ? _b : '');
            const fileAbsPath = path_1.default.resolve(baseDir, args.file);
            // TODO should we let this be handled by the function that handles resolving files?
            logReferencedFile(fileAbsPath);
            const handlePromiseError = createPromiseErrorHandler({
                node,
                ignoreMissingFiles: options.ignoreMissingFiles,
                fromFile: file.name,
                filepath: args.file,
            });
            if (typeof options.fileSnippetProvider === 'function') {
                promises.push(options.fileSnippetProvider({
                    baseDir,
                    ...args,
                }).then(snippetContent => {
                    node.value = snippetContent;
                }).catch(handlePromiseError));
            }
            else {
                const fileContent = options.fileContentProvider
                    ? options.fileContentProvider({
                        baseDir,
                        ...args,
                    })
                    : fs_1.default.promises
                        .readFile(fileAbsPath, 'utf8')
                        .then(x => x.toString());
                // in case provided function returned string instead of Promise<string>
                const promiseFileContent = fileContent instanceof Promise ? fileContent : Promise.resolve(fileContent);
                promises.push(promiseFileContent
                    .then(fileContent => {
                    node.value = getSnippet(fileContent, args);
                })
                    .catch(handlePromiseError));
            }
        }
        if (promises.length) {
            return Promise.all(promises).then(() => {
                // map result to void for return type
            });
        }
    };
}
exports.default = codeImport;
function createPromiseErrorHandler({ node, ignoreMissingFiles, fromFile, filepath }) {
    return function handlePromiseError(e) {
        if ((e === null || e === void 0 ? void 0 : e.code) === 'ENOENT' && ignoreMissingFiles) {
            node.value = `Referenced file from ${fromFile} (${filepath}) not found.`;
            return;
        }
        if (e instanceof errors_1.UnauthenticatedError) {
            throw new Error((0, auth_1.getNeedToAuthenticateMessage)());
        }
        if (e instanceof errors_1.OfflineError) {
            throw new Error('You have requested a new code snippet from another repository but don\'t appear to be on the corporate network.\n\nPlease connect to the VPN or lighthouse and then retry the build.');
        }
        if (e instanceof errors_1.InvalidReferenceError) {
            throw new Error(`It looks like you have added an invalid code snippet.\n${e.message}`);
        }
        throw e;
    };
}
function getSnippet(fileContent, args) {
    let lines = fileContent.trim().split('\n');
    let startingLine = 0;
    let endingLine = undefined;
    if (args.start) {
        const numbers = getLineNumbersOfOccurrence(lines, args.start);
        if (numbers.length === 0) {
            throw new Error(`Code block start marker "${args.start}" not found in file ${args.file}`);
        }
        if (numbers.length > 1) {
            throw new Error(`Ambiguous code block start marker. Found more than once in ${args.file}, at lines ${numbers}`);
        }
        startingLine = numbers[0] + 1;
    }
    if (args.end) {
        const numbers = getLineNumbersOfOccurrence(lines, args.end);
        if (numbers.length === 0) {
            throw new Error(`Code block end marker "${args.end}" not found in file ${args.file}`);
        }
        const validNumbers = numbers.filter(num => num > startingLine);
        if (validNumbers.length > 1) {
            throw new Error(`Ambiguous code block end marker. Found more than once in ${args.file}, at lines ${validNumbers}`);
        }
        endingLine = validNumbers[0];
    }
    lines = lines.slice(startingLine, endingLine);
    lines = trimNewlines(lines);
    return removeCommonIndentation(lines).join('\n');
}
exports.getSnippet = getSnippet;
function trimNewlines(lines) {
    let start = 0;
    let end = lines.length - 1;
    while (start < end && lines[start].trim() === '') {
        start++;
    }
    while (end > start && lines[end].trim() === '') {
        end--;
    }
    return lines.slice(start, end + 1);
}
function removeCommonIndentation(lines) {
    const commonIndentation = lines.reduce((minIndentation, line) => {
        if (line === '') {
            return minIndentation;
        }
        const m = line.match(/^( *)/);
        if (!m) {
            return 0;
        }
        return Math.min(m[1].length, minIndentation);
    }, Number.MAX_VALUE);
    return lines.map((line) => line.slice(commonIndentation));
}
function getLineNumbersOfOccurrence(lines, searchTerm) {
    const lineNumbers = [];
    lines.forEach((line, index) => {
        const startIndex = line.indexOf(searchTerm);
        if (startIndex > -1) {
            lineNumbers.push(index);
        }
    });
    return lineNumbers;
}
function hasLang(node) {
    return Boolean(node.lang) && typeof node.lang === 'string';
}
function logReferencedFile(filepath) {
    const relativePath = path_1.default.relative(process.cwd(), filepath);
    referencedFiles.add(relativePath);
}
function getReferencedFiles() {
    return Array.from(referencedFiles);
}
exports.getReferencedFiles = getReferencedFiles;
