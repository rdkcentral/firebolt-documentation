"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 *
 * @format
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forTesting = exports.updateTrackingFile = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const child_process_1 = __importDefault(require("child_process"));
const GENERATED_TAG = '@' + 'generated'; // Not using a plain tring literal or THIS FILE will be treated as generated.
let updatingTrackingFile = false;
async function updateTrackingFile(args) {
    if (updatingTrackingFile) {
        // This function reads and writes to the same file.
        // It's not safe to use concurrently.
        return;
    }
    try {
        updatingTrackingFile = true;
        const { staticDocsProject, trackingFileLocation, referencedFiles, appendOnly, } = args;
        let repoRoot;
        try {
            repoRoot = await getHgRoot();
        }
        catch (e) {
            console.info('Not in hg repo. No need to update watched files.');
            return;
        }
        const content = await fs_1.promises.readFile(path_1.default.resolve(repoRoot, trackingFileLocation));
        const map = deserialize(content.toString());
        const normalizedReferencedFiles = referencedFiles.map(f => path_1.default.relative(repoRoot, path_1.default.resolve(f)));
        const newMap = computeWatchedFilesMapIfChanged(map, staticDocsProject, normalizedReferencedFiles, appendOnly);
        if (newMap !== null) {
            const newContent = serialize(newMap);
            await fs_1.promises.writeFile(path_1.default.resolve(repoRoot, trackingFileLocation), newContent);
        }
    }
    catch (e) {
        console.warn('Unable to update tracking file', e);
    }
    finally {
        updatingTrackingFile = false;
    }
}
exports.updateTrackingFile = updateTrackingFile;
function computeWatchedFilesMapIfChanged(originalMap, thisProject, referencedFiles, appendOnly) {
    var _a;
    const oldFileList = (_a = originalMap[thisProject]) !== null && _a !== void 0 ? _a : [];
    const fileSet = new Set([...referencedFiles]);
    if (appendOnly) {
        oldFileList.forEach(f => fileSet.add(f));
    }
    if (oldFileList.length === fileSet.size &&
        oldFileList.every(f => fileSet.has(f))) {
        return null;
    }
    return {
        ...originalMap,
        [thisProject]: Array.from(fileSet),
    };
}
async function getHgRoot() {
    const p = child_process_1.default.exec('hg root');
    return new Promise((resolve, reject) => {
        var _a;
        p.on('exit', (code) => {
            if (code !== 0) {
                reject(code);
            }
        });
        (_a = p.stdout) === null || _a === void 0 ? void 0 : _a.on('data', chunk => {
            resolve(chunk.toString().trim());
        });
    });
}
function deserialize(content) {
    const result = {};
    const sections = content.split('\n\n');
    sections.forEach(s => {
        const lines = s.split('\n').filter(l => l != '' && !l.startsWith('#'));
        if (lines.length == 0) {
            return;
        }
        const projectName = lines[0];
        const files = lines.slice(1);
        result[projectName] = files;
    });
    return result;
}
function serialize(map) {
    const lines = [`# ${GENERATED_TAG}`];
    for (const key of Object.keys(map).sort()) {
        lines.push(key);
        map[key].sort().forEach(file => lines.push(file));
        lines.push('');
    }
    return lines.join('\n');
}
exports.forTesting = {
    serialize,
    deserialize,
    computeWatchedFilesMapIfChanged,
};
