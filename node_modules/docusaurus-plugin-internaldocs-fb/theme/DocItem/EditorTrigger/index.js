"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 *
 * @format
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorTrigger = void 0;
const react_1 = __importStar(require("react"));
const react_modal_1 = __importDefault(require("react-modal"));
const Link_1 = __importDefault(require("@docusaurus/Link"));
const theme_common_1 = require("@docusaurus/theme-common");
const useGlobalData_1 = require("@docusaurus/useGlobalData");
const useBaseUrl_1 = __importDefault(require("@docusaurus/useBaseUrl"));
const Button_1 = require("../Button");
const SDocEditor_1 = require("../SDocEditor");
const DocMetaProvider_1 = require("../../DocMetaProvider");
const internal_1 = require("../../../internal");
const inpageeditor_1 = require("../../../internal/inpageeditor");
const internal_2 = require("../../../internal");
const helpers_1 = require("../utils/helpers");
const styles_module_css_1 = __importDefault(require("./styles.module.css"));
function ContinueEditingPrompt({ onDecision, lastEditTimestamp, }) {
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("h3", null, "Continue"),
        react_1.default.createElement("p", null, "Do you want to continue with your last edit?"),
        lastEditTimestamp && (react_1.default.createElement("p", null,
            "created on: ",
            new Date(Number(lastEditTimestamp)).toLocaleString())),
        react_1.default.createElement("div", { style: {
                display: 'flex',
                flexDirection: 'row',
                gap: 12,
                justifyContent: 'end',
            } },
            react_1.default.createElement(Button_1.Button, { onClick: () => {
                    onDecision(false);
                } }, "No"),
            react_1.default.createElement(Button_1.Button, { onClick: () => {
                    onDecision(true);
                } }, "Yes"))));
}
function useInternaldocsPluginData() {
    // TODO: validation
    return (0, useGlobalData_1.usePluginData)('internaldocs-fb');
}
const newPathValidation = {
    isMarkdownish: (x) => /\.mdx?$/i.test(x),
    hasBannedCharacters: (x) => x.replace(/[\w\d.-_]/gi, '').length > 0,
    hasParentDirAccess: (x) => x.startsWith('../') || x.includes('/../'),
};
function NewFilePathStep({ onSubmit, repoRootToWebsiteRoot, }) {
    const [filepath, setFilepath] = (0, react_1.useState)('');
    const isInvalid = !filepath ||
        !newPathValidation.isMarkdownish(filepath) ||
        newPathValidation.hasBannedCharacters(filepath) ||
        newPathValidation.hasParentDirAccess(filepath);
    return (react_1.default.createElement("form", { onSubmit: e => {
            e.preventDefault();
            if (isInvalid)
                return;
            onSubmit(filepath);
        } },
        react_1.default.createElement("label", { style: { display: 'block', marginBottom: 12 } },
            react_1.default.createElement("span", null, "New page file path"),
            react_1.default.createElement("div", { style: { display: 'flex' } },
                react_1.default.createElement("code", null,
                    repoRootToWebsiteRoot,
                    "/"),
                react_1.default.createElement("input", { type: "text", value: filepath, placeholder: "docs/path/to/file.md", onChange: ({ target }) => setFilepath(target.value), style: { flexGrow: 1 }, autoFocus: true }))),
        isInvalid && (react_1.default.createElement("ul", { className: styles_module_css_1.default.filepath_validation_list },
            !newPathValidation.isMarkdownish(filepath) && (react_1.default.createElement("li", null, "You can only create markdown and mdx files, must end with `.mdx` or `.md`")),
            newPathValidation.hasBannedCharacters(filepath) && (react_1.default.createElement("li", null, "File path contains disallowed symbols. You can use alphanumricals, dot, slash, hyphen and underscore.")),
            newPathValidation.hasParentDirAccess(filepath) && (react_1.default.createElement("li", null, "You cannot create files outside of website directory")))),
        react_1.default.createElement(Button_1.Button, { type: "submit", disabled: isInvalid, style: { display: 'block', marginLeft: 'auto' } }, "Continue")));
}
/**
 * Editor modal has 5 main states
 * - `restore-session-prompt` - prompt to restore last session if possible, only for kind `modify`
 * - `input-new-page-path` - input and validate a new page path, only for kind `add`
 * - `loading-raw-content` - loading content from phabricator
 * - `editing` - editor + preview
 * - `submitting` - diff submition in progress
 * - `failed` - diff submition failed
 * - `success` - diff submition success
 */
function EditorWrapperModal({ isOpen, onClose, kind, editUrl, }) {
    var _a, _b, _c;
    const [modalState, setModalState] = (0, react_1.useState)({
        type: kind === inpageeditor_1.DiffKind.modify
            ? 'restore-session-prompt'
            : 'input-new-page-path',
    });
    const pluginData = useInternaldocsPluginData();
    const { repoRootToWebsiteRoot } = pluginData;
    const pageRawContentKey = (0, react_1.useMemo)(() => `pageRawContent-${(0, helpers_1.generateHash)(`${(0, internal_1.getEphemeralDiffNumber)()}${editUrl}`)}`, [editUrl]);
    const [pageRawContentVersion, setPageRawContentVersion] = (0, react_1.useState)(null);
    const filePathRelativeToDocs = (0, react_1.useMemo)(() => (0, helpers_1.getFilePathRelativeToDocsFolder)(editUrl, pluginData.docsDir), [editUrl, pluginData.docsDir]);
    const url = (0, useBaseUrl_1.default)(`_src/${filePathRelativeToDocs}`);
    const pageLocalStorageSlot = (0, react_1.useMemo)(() => (0, theme_common_1.createStorageSlot)(pageRawContentKey), [pageRawContentKey]);
    const onEditorSubmit = (0, react_1.useCallback)(() => {
        var _a;
        setModalState({ type: 'submitting' });
        const newContent = pageRawContentVersion === null || pageRawContentVersion === void 0 ? void 0 : pageRawContentVersion.pageRawContent;
        const projectName = null;
        const diffNumber = (0, internal_1.hasEphemeralDiffNumber)()
            ? Number((_a = (0, internal_1.getEphemeralDiffNumber)()) === null || _a === void 0 ? void 0 : _a.slice(1))
            : null;
        if (pageRawContentVersion == null) {
            throw new Error('Attempting to submit a diff with null content, report to staticdocs oncall');
        }
        const filePathRelativeToRepoRoot = kind === inpageeditor_1.DiffKind.add
            ? pageRawContentVersion.newFilePath
            : editUrl
                ? (0, helpers_1.getFilePathRelativeToRepoRoot)(editUrl)
                : null;
        if (!filePathRelativeToRepoRoot) {
            const message = `The provided url ${editUrl} is invalid`;
            setModalState({
                type: 'failed',
                reason: message,
            });
            throw new Error(message);
        }
        if (newContent == null) {
            setModalState({
                type: 'failed',
                reason: "The page's raw content cannot be null",
            });
            throw new Error("The page's raw content cannot be null");
        }
        internal_1.inpageeditor
            .submitDiff({
            file_path: filePathRelativeToRepoRoot,
            new_content: newContent,
            project_name: projectName,
            diff_number: diffNumber,
            diff_kind: kind,
        })
            .then(res => {
            setModalState({
                type: 'success',
                url: res.xfb_static_docs_editor_create_diff.url,
                diffId: res.xfb_static_docs_editor_create_diff.number_with_prefix,
            });
        })
            .catch(err => {
            const message = `Error occurred while trying to create diff from editor. Stack trace ${err}`;
            setModalState({
                type: 'failed',
                reason: message,
            });
            throw new Error(message);
        });
    }, [setModalState, editUrl, pageRawContentVersion, kind]);
    (0, react_1.useEffect)(() => {
        if (kind === inpageeditor_1.DiffKind.add)
            return;
        const currentPageLocalStorageSlotValue = pageLocalStorageSlot.get();
        try {
            setPageRawContentVersion(currentPageLocalStorageSlotValue
                ? JSON.parse(currentPageLocalStorageSlotValue)
                : null);
        }
        catch (e) {
            setPageRawContentVersion(null);
        }
    }, [pageLocalStorageSlot, kind]);
    const onRestoreDecision = (0, react_1.useCallback)((restore) => {
        if (restore) {
            const fromLS = pageLocalStorageSlot.get();
            if (fromLS == null) {
                throw new Error('Cannot restore page raw content with no saved state in local storage');
            }
            const parsed = JSON.parse(fromLS);
            setModalState({
                type: 'editing',
            });
            setPageRawContentVersion({
                pageRawContent: parsed.pageRawContent,
                timestamp: parsed.timestamp,
                newFilePath: '',
            });
        }
        else {
            setModalState({
                type: 'loading-raw-content',
            });
            fetch(url)
                .then(response => {
                if (!response.ok) {
                    const message = 'Failed to fetch page raw content from server.';
                    setModalState({
                        type: 'failed',
                        reason: message,
                    });
                    throw new Error(message);
                }
                return response.text();
            })
                .then(data => {
                setPageRawContentVersion({
                    pageRawContent: data,
                    timestamp: Date.now().toString(),
                    newFilePath: '',
                });
                setModalState({
                    type: 'editing',
                });
            })
                .catch(err => {
                setModalState({
                    type: 'failed',
                    reason: `Error occurred while trying fetch page raw content. Stack trace ${err}`,
                });
            });
        }
    }, [setModalState, url, pageLocalStorageSlot]);
    // On mount check if we have saved changes in local storage
    // if none found proceed to load content from phabriacator
    (0, react_1.useEffect)(() => {
        if (kind === inpageeditor_1.DiffKind.add)
            return;
        const fromLS = pageLocalStorageSlot.get();
        if (fromLS === null) {
            onRestoreDecision(false);
        }
        else {
            setModalState({ type: 'restore-session-prompt' });
        }
    }, 
    // ignoring to use hook as componentDidMount
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    const handleContentUpdate = (0, react_1.useCallback)((value) => {
        pageLocalStorageSlot.set(JSON.stringify(value));
        setModalState({
            type: 'editing',
        });
        setPageRawContentVersion({
            pageRawContent: value.pageRawContent,
            timestamp: value.timestamp,
            newFilePath: value.newFilePath,
        });
    }, [setModalState, pageLocalStorageSlot]);
    const modalStyle = (0, react_1.useMemo)(() => {
        // 1916 is double of 958 which is the width of page content column
        // so the preview will be displayed the same width as page content
        let contentWidth = 'min(80vw, 1916px)';
        if (modalState.type === 'restore-session-prompt' ||
            modalState.type === 'loading-raw-content') {
            contentWidth = 'min(20, 360px)';
        }
        if (modalState.type === 'input-new-page-path') {
            contentWidth = 'min(40, 520px)';
        }
        return {
            content: {
                width: contentWidth,
                maxHeight: 'calc(100% - 100px)',
                margin: '80px auto 10px',
                inset: 'auto',
                overscrollBehavior: 'contain',
            },
            overlay: {
                background: 'rgba(0, 0, 0, .5)',
                'overflow-y': 'auto',
                display: 'flex',
                alignItems: 'flex-start',
                justifyContent: 'center',
                zIndex: 10,
            },
        };
    }, [modalState.type]);
    const lastEditTimestamp = (_a = pageRawContentVersion === null || pageRawContentVersion === void 0 ? void 0 : pageRawContentVersion.timestamp) !== null && _a !== void 0 ? _a : null;
    return (react_1.default.createElement(react_modal_1.default
    // TODO: remove down the diff stack
    , { 
        // TODO: remove down the diff stack
        ariaHideApp: false, isOpen: isOpen, shouldCloseOnOverlayClick: false, shouldCloseOnEsc: false, style: modalStyle },
        modalState.type === 'restore-session-prompt' && (react_1.default.createElement(ContinueEditingPrompt, { onDecision: onRestoreDecision, lastEditTimestamp: lastEditTimestamp })),
        modalState.type === 'loading-raw-content' && (react_1.default.createElement("div", null, "Loading raw page content...")),
        modalState.type === 'input-new-page-path' && (react_1.default.createElement(NewFilePathStep, { repoRootToWebsiteRoot: repoRootToWebsiteRoot, onSubmit: filepath => {
                setPageRawContentVersion({
                    timestamp: Date.now().toString(),
                    pageRawContent: '',
                    newFilePath: `${repoRootToWebsiteRoot}/${filepath}`,
                });
                setModalState({ type: 'editing' });
            } })),
        modalState.type === 'editing' && (react_1.default.createElement(SDocEditor_1.SDocEditor, { pageRawContent: (_b = pageRawContentVersion === null || pageRawContentVersion === void 0 ? void 0 : pageRawContentVersion.pageRawContent) !== null && _b !== void 0 ? _b : '', diffKind: kind, newFilePath: (_c = pageRawContentVersion === null || pageRawContentVersion === void 0 ? void 0 : pageRawContentVersion.newFilePath) !== null && _c !== void 0 ? _c : '', setPageRawContentVersion: handleContentUpdate, onEditorSubmit: onEditorSubmit, handleCloseEditor: onClose, isSubmitting: false })),
        modalState.type === 'submitting' && react_1.default.createElement("div", null, "Submitting changes..."),
        modalState.type === 'success' && (react_1.default.createElement("div", null,
            "Diff has been submitted",
            ' ',
            react_1.default.createElement(Link_1.default, { to: modalState.url }, modalState.diffId))),
        modalState.type === 'failed' && react_1.default.createElement("div", null,
            "Error: ",
            modalState.reason)));
}
function EditorTrigger({ position, }) {
    var _a;
    const docMetadata = (_a = (0, DocMetaProvider_1.useDocMeta)()) === null || _a === void 0 ? void 0 : _a.metadata;
    const [state, setState] = (0, react_1.useState)({
        isOpen: false,
        kind: inpageeditor_1.DiffKind.modify,
    });
    const pluginData = useInternaldocsPluginData();
    const filePathRelativeToDocs = (0, react_1.useMemo)(() => (docMetadata === null || docMetadata === void 0 ? void 0 : docMetadata.editUrl)
        ? (0, helpers_1.getFilePathRelativeToDocsFolder)(docMetadata.editUrl, pluginData.docsDir)
        : null, [docMetadata, pluginData.docsDir]);
    // most likely by placing EditorTrigger outside of DocItem
    if (docMetadata == null)
        return null;
    const { editUrl } = docMetadata;
    if (position === 'before-post' && pluginData.opts.enableEditor !== 'top')
        return null;
    if (position === 'after-post' &&
        ![true, 'bottom'].includes(pluginData.opts.enableEditor))
        return null;
    if (!(editUrl || docMetadata.lastUpdatedAt || docMetadata.lastUpdatedBy))
        return null;
    // allow force enable editor during development with `?enableEditor=1`
    const forceAllowEditor = typeof window !== 'undefined' &&
        new URLSearchParams(window.location.search).get('enableEditor') === '1';
    // what's the differnce to <EditThisPage /> ?
    const hasEditInternalPage = editUrl &&
        filePathRelativeToDocs &&
        (forceAllowEditor ||
            ((0, internal_2.isInternal)() && process.env.NODE_ENV === 'production'));
    return hasEditInternalPage ? (react_1.default.createElement("div", { className: `margin-vert--${position === 'after-post' ? 'xl' : 'xs'}` },
        react_1.default.createElement(Button_1.Button, { onClick: () => setState({ isOpen: true, kind: inpageeditor_1.DiffKind.modify }), style: { marginRight: 8 } }, "Edit this page"),
        react_1.default.createElement(Button_1.Button, { onClick: () => setState({ isOpen: true, kind: inpageeditor_1.DiffKind.add }) }, "Add new page"),
        state.isOpen ? (react_1.default.createElement(EditorWrapperModal, { isOpen: true, kind: state.kind, onClose: () => {
                setState({
                    isOpen: false,
                    kind: inpageeditor_1.DiffKind.modify,
                });
            }, editUrl: editUrl })) : null)) : null;
}
exports.EditorTrigger = EditorTrigger;
