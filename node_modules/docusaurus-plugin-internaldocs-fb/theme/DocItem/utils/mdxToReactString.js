"use strict";
/**
 * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mdxToReactString = void 0;
const remark_gfm_1 = __importDefault(require("remark-gfm"));
const unist_util_remove_1 = require("unist-util-remove");
// preserve `.js` extension for ESM tests
const compile_js_1 = require("@mdx-js/mdx/lib/compile.js");
// preserve `.js` extension for ESM tests
const remarkMermaid_js_1 = require("./remarkMermaid.js");
const importedItems = new Map();
const removeEsmImportsExports = () => (tree) => (0, unist_util_remove_1.remove)(tree, (node) => {
    var _a, _b, _c;
    if (node.type === 'mdxjsEsm') {
        // estree is untyped in unist :(
        /* eslint-disable @typescript-eslint/no-explicit-any */
        (_c = (_b = (_a = node.data) === null || _a === void 0 ? void 0 : _a.estree) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.forEach((estreeNode) => {
            if (estreeNode.type === 'ImportDeclaration') {
                estreeNode.specifiers.forEach((specifier) => {
                    importedItems.set(specifier.local.name, estreeNode.source.value);
                });
            }
        });
        /* eslint-enable @typescript-eslint/no-explicit-any */
        return true;
    }
    return false;
});
const LINES_TO_EXCLUDE = new Set([
    '/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/',
    'import React from "react";',
    'export default MDXContent;',
]);
/** returns `null` if failed to transpile */
function mdxToReactString(src) {
    const regexExpressionToRemoveFrontMatter = /^---(.|\n)*?---/;
    try {
        const code = (0, compile_js_1.compileSync)(src.replace(regexExpressionToRemoveFrontMatter, '')
            .split('\n')
            // XDM breaks when encounters html comments
            // as it tries to interpret them as jsx elements
            // so manually replacing them to jsx expression comments
            // @see https://github.com/wooorm/xdm/issues/61
            .map(line => {
            const match = line.trim().match(/^<!--(.*)-->$/);
            return match ? `{/*${match[1]}*/}` : line;
        })
            .join('\n'), {
            remarkPlugins: [
                [remarkMermaid_js_1.remarkMermaid, { version: 'v2' }],
                remark_gfm_1.default,
                removeEsmImportsExports,
            ],
            format: 'mdx',
            jsxRuntime: 'classic',
            outputFormat: 'program',
        })
            .value.toString()
            .replace('const _components =', 'let _components =')
            .split('\n')
            .filter(x => !LINES_TO_EXCLUDE.has(x))
            .map(x => {
            const match = x.match(/if \(!(.+)\) _missingMdxReference/);
            if (match === null)
                return x;
            const name = match[1];
            return `  if (!${name}) ${name} = _components.__unknownComponent("${name}");`;
        })
            .join('\n');
        return {
            code,
            importedComponents: Object.fromEntries([...importedItems]),
        };
    }
    catch (e) {
        console.warn('Transpiler error', e);
        return { code: null, importedComponents: {} };
    }
    finally {
        importedItems.clear();
    }
}
exports.mdxToReactString = mdxToReactString;
